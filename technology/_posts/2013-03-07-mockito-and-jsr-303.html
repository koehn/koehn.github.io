---
layout: techpost
title: Mockito and JSR-303
---

My current client maintains contracts to insure methods are called with the right parameters. Sad thing is that they way they've done this to date has involved writing statements into their interface implementation classes. There are several downsides to this approach:<br /><ol><li>There's no way to validate that unit tests using mocks of the interfaces are adhering to the contract.</li><li>Every implementation must write the same contract code again and again</li><li>Developers calling the interface must look at the implementations to determine what the contract is to which they must adhere.</li></ol>Often we use annotations to define simple contracts for APIs. I was hoping Mockito had some kind of system in place to verify that invocations on mocks met the spec in the annotated interface, but no joy. So, I wrote one. You can get a copy from <a href="https://github.com/koehn/mockito">my GitHub fork</a>. Of course, I submitted a <a href="https://github.com/mockito/mockito/pull/9">pull request</a> to the <a href="http://www.mockito.org/">Mockito</a> people to try to get them to mainline it. We'll see what they think. <br /><br />So now you can have an interface like this:<br /><br /><pre>public interface Foo {</pre><pre>&nbsp;   @NotNull String getMessage();</pre><pre>&nbsp;   @NotNull Bar getBar(@NotNull String barId);</pre><pre>}&nbsp;</pre><pre>&nbsp;<br /></pre>And when you create your mock like this:<br /><pre>&nbsp;</pre><pre>Foo foo = mock(Foo.class, withSettings().validate().</pre><pre>    validatorFactory(Validation.buildDefaultValidatorFactory());</pre><pre></pre>Then, if you call this from your class under test:<br /><pre>&nbsp;</pre><pre>foo.getBar(null)</pre><pre>&nbsp;</pre><br />Mockito will automatically throw an exception indicating you've violated Foo's contract.<br /><br />It works both ways too! Let's say you forgot to mock out a call to getBar() above. If your test does something against your mock like:<br /><pre>&nbsp;</pre><pre>Bar bar = foo.getBar("123");</pre><pre>&nbsp;</pre><br />Mockito will throw an exception because the interface says the result may not be null, but your mock will in fact return null from this method (because null is the default value Mockito returns). 
